"""A simple chat app based on Redis PUBSUB.
The chat also uses GPG to encrypt the messages
 sent to redis
"""


import threading
import datetime
from pathlib import Path
from configparser import ConfigParser
import json
import redis
import gnupg

APP_CONFIG = ConfigParser()
APP_CONFIG.read('config.ini')


class GetChats(threading.Thread):
    """Threading class to create threads to listen for incoming messages
    """

    def __init__(self, chat, pubsub, gpg):
        """Constructor which takes in the redis PubSub
        object and the name of the channel(The chat)
        """
        threading.Thread.__init__(self)
        self.chat = chat  # Name of Redis Channel/Chat
        self.pubsub = pubsub  # Redis PubSub object
        self.gpg = gpg

    def run(self):
        self.pubsub.subscribe(self.chat)  # Subscribe to Redis Channel/Chat
        for message in self.pubsub.listen():  # Listening to on channel for new messages
            if message["type"] == 'message':  # Only listen to messages and not subscriptions
                decrypted_data = self.gpg.decrypt(
                    str(message["data"].decode("utf-8")))
                print(str(datetime.datetime.now())+" : " + decrypted_data)


class JoinChat(threading.Thread):
    """Threading class to manage incomming users and their keys
    """

    def __init__(self, redisobj, gpg):
        threading.Thread.__init__(self)
        self.redis = redisobj
        self.gpg = gpg

    def run(self):
        pubsub = self.redis.pubsub()
        pubsub.subscribe(APP_CONFIG.get("redis", "joinchannel"))
        for message in pubsub.listen():  # Listening to on channel for new messages
            if message["type"] == 'message':  # Only listen to messages and not subscriptions
                for keyitem in self.gpg.list_keys():
                    public_key = json.loads(
                        str(message["data"].decode("utf-8")))["pub_ascii"]
                    fingerprint = self.gpg.export_keys(keyitem["fingerprint"])
                    recusername = json.loads(str(
                        message["data"].decode("utf-8")))["username"]
                    keyusername = keyitem["uids"][0].split("<")[0].strip()
                    if (public_key == fingerprint) and (recusername == keyusername):
                        self.redis.publish(APP_CONFIG.get(
                            "redis", "joinchannel"), "KEYFOUNDANDACCEPTED")
                    elif recusername == keyusername:
                        self.redis.publish(APP_CONFIG.get(
                            "redis", "joinchannel"), "USERNAMEFOUNDANDREJECTED")
                    else:
                        self.gpg.import_keys(json.loads(
                            message["data"].decode("utf-8"))["pub_ascii"])
                        self.redis.publish(APP_CONFIG.get(
                            "redis", "joinchannel"), "NEWUSERNAMEFOUNDANDACCEPTED")


def username(gpg, redisobj):
    """Function to check if username is available
    """
    while True:
        if input("Use identity from previous keys?(y/n)").upper() == "Y":
            count = 1
            # Get all private keys of the user
            for usernamekeyitem in gpg.list_keys(True):
                print(str(count) + ". " + str(usernamekeyitem["uids"]))
                count += 1
            # Set select key as identity
            identity = gpg.list_keys(
                True)[int(input("Select your identity")) - 1]
            my_username = identity["uids"][0].split("<")[0].strip()
            key = identity["fingerprint"]
            ascii_armoured_public_key = gpg.export_keys(key)
        else:
            my_username = input("Username:\n")
            email = input("Email Address(Optional):")
            email = email if email != "" else my_username + APP_CONFIG.get(
                "gpg", "email_host")  # Generate an email if not used
            input_data = gpg.gen_key_input(
                key_type=APP_CONFIG.get("gpg", "key_type"), name_email=email,
                name_comment="Generated by Redis Chat", name_real=my_username,
                key_length=APP_CONFIG.get("gpg", "key_length"))  # Data to generate key pair
            key = gpg.gen_key(input_data)  # Generate key
            ascii_armoured_public_key = gpg.export_keys(str(key))
        pub_sub = redisobj.pubsub()  # Redis Pub/Sub Object
        join = {
            "username": my_username,
            "pub_ascii": ascii_armoured_public_key}  # User Identity in current chat session
        # Tell everyone your identity
        redisobj.publish(APP_CONFIG.get(
            "redis", "joinchannel"), json.dumps(join))
        pub_sub.subscribe(APP_CONFIG.get(
            "redis", "joinchannel"))
        message = pub_sub.get_message()
        if message != "USERNAMEFOUNDANDREJECTED":
            break
        return my_username


def main():
    # Location of keys to be used for encryption/decryption (To be made Dynamic)
    GPG = gnupg.GPG(gnupghome=str(Path.home()) + '/redischat')
    GPG.encoding = 'utf-8'
    R = redis.Redis(host=APP_CONFIG.get("redis", "host"), port=APP_CONFIG.get("redis", "port"),
                    db=APP_CONFIG.get("redis", "db"))  # Connect to Redis server
    P = R.pubsub()
    MY_USERNAME = username(GPG, R)
    JOIN_TRACKER = JoinChat(R, GPG)
    JOIN_TRACKER.start()
    CURRENT_CHAT = None
    MY_CHATS = []
    while True:
        COMMAND = input("\n >")
        if COMMAND[0:5] == "/chat":
            if COMMAND[6:0] in MY_CHATS:
                CURRENT_CHAT = COMMAND[6:]
            else:
                # Create a new chat with that user
                CHAT = GetChats(
                    "".join(sorted([MY_USERNAME, COMMAND[6:]])), P, GPG)
                CHAT.start()
                CURRENT_CHAT = COMMAND[6:]
                MY_CHATS.append(CHAT)
                # Set the name of thread/Listener to identify
                CHAT.setName(COMMAND[6:])
        elif COMMAND[0:8] == "/mychats":
            for item in MY_CHATS:
                print(item.getName())
        elif COMMAND[0] == "/":
            print("Unknown Command")
        else:
            R.publish(
                "".join(sorted([MY_USERNAME, CURRENT_CHAT])),
                MY_USERNAME+" : "+GPG.encrypt(COMMAND, CURRENT_CHAT))  # Send message


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Done. Exiting!")
