"""A simple chat app based on Redis PUBSUB.
The chat also uses GPG to encrypt the messages
 sent to redis
"""


import threading
import datetime
from pathlib import Path
from configparser import ConfigParser
import redis
import gnupg

APP_CONFIG = ConfigParser()
APP_CONFIG.read('config.ini')


class GetChats(threading.Thread):
    """Threading class to create threads to listen for incoming messages
    """

    def __init__(self, chat, pubsub):
        """Constructor which takes in the redis PubSub
        object and the name of the channel(The chat)
        """
        threading.Thread.__init__(self)
        self.chat = chat  # Name of Redis Channel/Chat
        self.pubsub = pubsub  # Redis PubSub object

    def run(self):
        self.pubsub.subscribe(self.chat)  # Subscribe to Redis Channel/Chat
        for message in self.pubsub.listen():  # Listening to on channel for new messages
            if message["type"] == 'message':  # Only listen to messages and not subscriptions
                print(str(datetime.datetime.now())+" : " +
                      message["data"].decode("utf-8"))


if __name__ == "__main__":
    # Location of keys to be used for encryption/decryption (To be made Dynamic)
    GPG = gnupg.GPG(gnupghome=str(Path.home()) + '/redischat')
    GPG.encoding = 'utf-8'
    R = redis.Redis(host=APP_CONFIG.get("redis", "host"), port=APP_CONFIG.get("redis", "port"),
                    db=APP_CONFIG.get("redis", "db"))  # Connect to Redis server
    if input("Use identity from previous keys?(y/n)").upper() == "Y":
        COUNT = 1
        for item in GPG.list_keys(True):  # Get all private keys of the user
            print(str(COUNT) + ". " + str(item["uids"]))
            COUNT += 1
        # Set select key as identity
        IDENTITY = GPG.list_keys(True)[int(input("Select your identity")) - 1]
        MY_USERNAME = IDENTITY["uids"][0].split("<")[0].strip()
        KEY = IDENTITY["fingerprint"]
        ASCII_ARMOURED_PUBLIC_KEY = GPG.export_keys(KEY)
    else:
        MY_USERNAME = input("Username:\n")
        EMAIL = input("Email Address(Optional):")
        EMAIL = EMAIL if EMAIL != "" else MY_USERNAME + \
            APP_CONFIG.get(
                "gpg", "email_host")  # Generate an email if not used
        INPUT_DATA = GPG.gen_key_input(
            key_type=APP_CONFIG.get("gpg", "key_type"), name_email=EMAIL,
            name_comment="Generated by Redis Chat", name_real=MY_USERNAME,
            key_length=APP_CONFIG.get("gpg", "key_length"))  # Data to generate key pair
        KEY = GPG.gen_key(INPUT_DATA)  # Generate key
        ASCII_ARMOURED_PUBLIC_KEY = GPG.export_keys(KEY)
    P = R.pubsub()  # Redis Pub/Sub Object
    JOIN = {
        "username": MY_USERNAME,
        "fingerprint": KEY,
        "pub_ascii": ASCII_ARMOURED_PUBLIC_KEY}  # User Identity in current chat session
    # Tell everyone your identity
    R.publish(APP_CONFIG.get("redis", "joinchannel"), str(JOIN))
    CURRENT_CHAT = None
    MY_CHATS = []
    while True:
        COMMAND = input("\n >")
        if COMMAND[0:5] == "/chat":
            if COMMAND[6:0] in MY_CHATS:
                CURRENT_CHAT = COMMAND[6:]
            else:
                # Create a new chat with that user
                CHAT = GetChats("".join(sorted([MY_USERNAME, COMMAND[6:]])), P)
                CHAT.start()
                CURRENT_CHAT = COMMAND[6:]
                MY_CHATS.append(CHAT)
                # Set the name of thread/Listener to identify
                CHAT.setName(COMMAND[6:])
        elif COMMAND[0:8] == "/mychats":
            for item in MY_CHATS:
                print(item.getName())
        elif COMMAND[0] == "/":
            print("Unknown Command")
        else:
            R.publish(
                "".join(sorted([MY_USERNAME, CURRENT_CHAT])),
                MY_USERNAME+" : "+COMMAND)  # Send message
